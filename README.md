# Falcon BMS Picos
This project adds an Object Oriented way to program picos for a Falcon BMS simulation setup using C++.

This can be used in parralel with my other project [FalconBMSToSerial](https://github.com/LucyV4/FalconBMSToSerial) which sends the memory data from Falcon BMS to serial ports.

## Requirements
For this project I would recommend using the [VSCode Raspberry Pi Pico extension](https://marketplace.visualstudio.com/items?itemName=raspberry-pi.raspberry-pi-pico). This allows for easy selection of the Raspberry Pi Pico type and Pico SDK version. If you want to build it manually you will need to change the Cmake files as well as install the following packages.
- CMake
- An arm gcc compiler
- Ninja
- pico-sdk
- picotool 
- openocd

Next to this I would recommend installing `make` for windows using [Chocolatey](https://chocolatey.org/). While this is not required, it allows you to easily build, compile and flash the uf2 files. 

## Usage

### Building and compiling
To build and compile the 'uf2' files you just need to run 
```
$ make
````

### Flashing the pico
If you want to flash the pico you can run
```
$ make flash TARGET=[pico_name]
```

This will flash automatically `[pico_name].uf2` into a pico with bootsel mode on. If there is no pico with bootsel mode it will first try and find a pico with the name `[pico_name]` and restart it into bootsel and then flash it. If it still cannot find a valid pico `make flash` will not work.

This means the first time you want to flash a pico you should put it in bootsel mode automatically, after you have flashed the program generated by the code you can just run this command.

Next to this you can also put the pico into bootsel manually and copy the corresponding file from `firmware [pico_name].uf2` into the pico.

### Adding a new pico
You can easily create a pico by just making a new folder and 2 files. the 'cpp' file for the code and a `CMakeLists.txt` for compiling. You should do this inside of the `picos` folder where there is 2 examples. Next to this you will also need to edit `picos/CMakeLists.txt` to add the new subdirectory.

Below I have added a template for the 'cpp' file and the `CMakeLists.txt`
```c++
// [pico_name].cpp

#include "pico_device.h"
#include "output_led.h"
#include "output_display.h"
#include "input_button.h"
#include "input_potentiometer.h"
#include "uart_module.h"
#include "pico_data.h"

PicoDevice myPico("[PICO_NAME]");

int main() {
	/*
	 ** EXAMPLE OUTPUT MODULES
	 */
	myPico.add_output(new LedOutput(6, FlightData::LightBits2::Unk));

	std::function<void(PicoData&, Display&)> ewpiDisplayFunc;
	ewpiDisplayFunc = [](PicoData& data, Display& display) {
		display.writef(0, "%d", data.flightData.ChaffCount);
		display.writef(4, "%*d", 4, data.flightData.FlareCount);
		display.writef(8, "JMR.data.");
	};
	myPico.add_output(new DisplayOutput(19, 21, 18, 17, 20, 16, 16, ewpiDisplayFunc));

	/*
	 ** EXAMPLE INPUT MODULES
	 */
	std::function<void(PicoData&, bool)> toggleButtonFunc;
	toggleButtonFunc = [](PicoData& data, bool button_on) {
		gpio_put(25, button_on);
		data.setButton(0, button_on);
	};
	myPico.add_input(new ButtonInput(10, toggleButtonFunc, ButtonMode::Toggle));

	myPico.add_input(new PotInput(28, 2, 0));

	/*
	 ** EXAMPLE UART MODULES
	 */
	std::function<void(PicoData&, uart_inst_t*)> uart0Func;
	uart0Func = [](PicoData& data, uart_inst_t* uart_inst) {
		bool flag = data.flightData.IsSet2(FlightData::LightBits2::Unk);
		uint8_t byte_to_send = flag;
		uart_putc(uart_inst, byte_to_send);
	};
	myPico.add_uart(new UARTModule(0, 1, uart0, uart0Func));

	// Start the pico
	myPico.start();
	return 0;
}
```

```cmake
# CMakeLists.txt
set(PICO_NAME "[pico_name]")

# Adds the source and shared sources
add_executable(${PICO_NAME} "${PICO_NAME}.cpp" ${SHARED_SOURCES})

# Adds the shared directories and shared libraries
target_include_directories(${PICO_NAME} PRIVATE ${SHARED_INCLUDE_DIRS})
target_link_libraries(${PICO_NAME} PRIVATE ${SHARED_LIBS})

# Set UF2 and ELF output directory
set_target_properties(${PICO_NAME} PROPERTIES
    ARCHIVE_OUTPUT_DIRECTORY ${FIRMWARE_DIR}
)

# Required
pico_add_extra_outputs(${PICO_NAME})
```

Mind that it is **important to have the** `[PICO_NAME]` **in the** `PicoDevice` **constructor in upper case and to keep the** `[pico_name]` **the same throughout for** `make flash` **to work.** See the ewpi and ewmu as examples, all the files are just ewpi/ewmu except for the device name which is in upper case.

## Credits
The `display.h` was adapted from [LedDisplay](https://github.com/PaulStoffregen/LedDisplay) by Paul Stoffregen. The font used in `display.h` is made by Andreas Taylor (see [https://github.com/Andy4495/HCMS39xx](https://github.com/Andy4495/HCMS39xx)). There was a previous version of the font made by Pascal Stang but it did not have the full range of characters I looked for.

Next to this I also took `flightdata.h` from the Falcon BMS tools such that I am able to use the flightdata classes.